import { AfterViewInit, ElementRef, EventEmitter, Injector, NgZone, OnChanges, OnDestroy, OnInit, ViewContainerRef } from '@angular/core';
import { Instance } from 'tippy.js';
import { Subject } from 'rxjs';
import { Content, ViewOptions, ViewRef, ViewService } from '@ngneat/overview';
import { NgChanges, TippyConfig, TippyInstance, TippyProps } from './tippy.types';
import * as i0 from "@angular/core";
export declare class TippyDirective implements OnChanges, AfterViewInit, OnDestroy, OnInit {
    protected platformId: string;
    protected globalConfig: TippyConfig;
    protected injector: Injector;
    protected viewService: ViewService;
    protected vcr: ViewContainerRef;
    protected zone: NgZone;
    protected hostRef: ElementRef;
    set appendTo(appendTo: TippyProps['appendTo']);
    content: Content | undefined | null;
    delay: TippyProps['delay'];
    duration: TippyProps['duration'];
    hideOnClick: TippyProps['hideOnClick'];
    interactive: TippyProps['interactive'];
    interactiveBorder: TippyProps['interactiveBorder'];
    maxWidth: TippyProps['maxWidth'];
    offset: TippyProps['offset'];
    placement: TippyProps['placement'];
    popperOptions: TippyProps['popperOptions'];
    showOnCreate: TippyProps['showOnCreate'];
    trigger: TippyProps['trigger'];
    triggerTarget: TippyProps['triggerTarget'];
    zIndex: TippyProps['zIndex'];
    animation: TippyProps['animation'];
    useTextContent: boolean;
    isLazy: boolean;
    variation: string;
    isEnabled: boolean;
    className: string | string[];
    onlyTextOverflow: boolean;
    staticWidthHost: boolean;
    data: any;
    useHostWidth: boolean;
    hideOnEscape: boolean;
    detectChangesComponent: boolean;
    popperWidth: number | string;
    customHost: HTMLElement;
    isVisible: boolean;
    visible: EventEmitter<boolean>;
    protected instance: TippyInstance;
    protected viewRef: ViewRef;
    protected destroyed: Subject<void>;
    protected props: Partial<TippyConfig>;
    protected enabled: boolean;
    protected variationDefined: boolean;
    protected viewOptions$: ViewOptions;
    /**
     * We had use `visible` event emitter previously as a `takeUntil` subscriber in multiple places
     * within the directive.
     * This is for internal use only; thus we don't have to deal with the `visible` event emitter
     * and trigger change detections only when the `visible` event is being listened outside
     * in the template (`<button [tippy]="..." (visible)="..."></button>`).
     */
    protected visibleInternal: Subject<boolean>;
    private visibilityObserverCleanup;
    private contentChanged;
    constructor(platformId: string, globalConfig: TippyConfig, injector: Injector, viewService: ViewService, vcr: ViewContainerRef, zone: NgZone, hostRef: ElementRef);
    ngOnChanges(changes: NgChanges<TippyDirective>): void;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    destroyView(): void;
    /**
     * This method is useful when you append to an element that you might remove from the DOM.
     * In such cases we want to hide the tooltip and let it go through the destroy lifecycle.
     * For example, if you have a grid row with an element that you toggle using the display CSS property on hover.
     */
    observeHostVisibility(): import("rxjs").Subscription;
    show(): void;
    hide(): void;
    enable(): void;
    disable(): void;
    protected updateProps(props: Partial<TippyConfig>): void;
    protected setProps(props: Partial<TippyConfig>): void;
    protected setStatus(): void;
    protected get host(): HTMLElement;
    protected get hostWidth(): number;
    protected createInstance(): void;
    protected resolveContent(instance: TippyInstance): string | Element;
    protected handleContextMenu(): void;
    protected handleEscapeButton(): void;
    protected checkOverflow(isElementOverflow: boolean): void;
    protected listenToHostResize(): void;
    protected setInstanceWidth(instance: Instance, width: string | number): void;
    private get isServerSide();
    private onHidden;
    private isOverflowing$;
    static ɵfac: i0.ɵɵFactoryDeclaration<TippyDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<TippyDirective, "[tp]", ["tippy"], { "appendTo": { "alias": "tpAppendTo"; "required": false; }; "content": { "alias": "tp"; "required": false; }; "delay": { "alias": "tpDelay"; "required": false; }; "duration": { "alias": "tpDuration"; "required": false; }; "hideOnClick": { "alias": "tpHideOnClick"; "required": false; }; "interactive": { "alias": "tpInteractive"; "required": false; }; "interactiveBorder": { "alias": "tpInteractiveBorder"; "required": false; }; "maxWidth": { "alias": "tpMaxWidth"; "required": false; }; "offset": { "alias": "tpOffset"; "required": false; }; "placement": { "alias": "tpPlacement"; "required": false; }; "popperOptions": { "alias": "tpPopperOptions"; "required": false; }; "showOnCreate": { "alias": "tpShowOnCreate"; "required": false; }; "trigger": { "alias": "tpTrigger"; "required": false; }; "triggerTarget": { "alias": "tpTriggerTarget"; "required": false; }; "zIndex": { "alias": "tpZIndex"; "required": false; }; "animation": { "alias": "tpAnimation"; "required": false; }; "useTextContent": { "alias": "tpUseTextContent"; "required": false; }; "isLazy": { "alias": "tpIsLazy"; "required": false; }; "variation": { "alias": "tpVariation"; "required": false; }; "isEnabled": { "alias": "tpIsEnabled"; "required": false; }; "className": { "alias": "tpClassName"; "required": false; }; "onlyTextOverflow": { "alias": "tpOnlyTextOverflow"; "required": false; }; "staticWidthHost": { "alias": "tpStaticWidthHost"; "required": false; }; "data": { "alias": "tpData"; "required": false; }; "useHostWidth": { "alias": "tpUseHostWidth"; "required": false; }; "hideOnEscape": { "alias": "tpHideOnEscape"; "required": false; }; "detectChangesComponent": { "alias": "tpDetectChangesComponent"; "required": false; }; "popperWidth": { "alias": "tpPopperWidth"; "required": false; }; "customHost": { "alias": "tpHost"; "required": false; }; "isVisible": { "alias": "tpIsVisible"; "required": false; }; }, { "visible": "tpVisible"; }, never, never, true, never>;
    static ngAcceptInputType_useTextContent: unknown;
    static ngAcceptInputType_isLazy: unknown;
    static ngAcceptInputType_onlyTextOverflow: unknown;
    static ngAcceptInputType_staticWidthHost: unknown;
    static ngAcceptInputType_useHostWidth: unknown;
    static ngAcceptInputType_hideOnEscape: unknown;
    static ngAcceptInputType_isVisible: unknown;
}
